# Шаблоны проектирования и архитектура программного обеспечения

## 1. Шаблоны проектирования: Команда, Стратегия, Шаблонный метод

### 1.1. Шаблон "Команда" (Command)

**Назначение**: Шаблон "Команда" инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь, логировать их и поддерживать операции отмены.

**Структура**:
- **Command** (интерфейс команды) — определяет интерфейс для выполнения операции
- **ConcreteCommand** (конкретная команда) — реализует интерфейс Command, выполняет действие, вызывая соответствующие операции на объекте-получателе
- **Invoker** (инициатор) — запрашивает выполнение команды
- **Receiver** (получатель) — выполняет работу, связанную с обработкой запроса
- **Client** (клиент) — создает объект ConcreteCommand и устанавливает его получателя

**Пример реализации**:
```java
// Интерфейс команды
interface Command {
    void execute();
}

// Получатель
class Light {
    public void turnOn() {
        System.out.println("Свет включен");
    }
    
    public void turnOff() {
        System.out.println("Свет выключен");
    }
}

// Конкретная команда
class TurnOnLightCommand implements Command {
    private Light light;
    
    public TurnOnLightCommand(Light light) {
        this.light = light;
    }
    
    @Override
    public void execute() {
        light.turnOn();
    }
}

// Конкретная команда
class TurnOffLightCommand implements Command {
    private Light light;
    
    public TurnOffLightCommand(Light light) {
        this.light = light;
    }
    
    @Override
    public void execute() {
        light.turnOff();
    }
}

// Инициатор
class RemoteControl {
    private Command command;
    
    public void setCommand(Command command) {
        this.command = command;
    }
    
    public void pressButton() {
        command.execute();
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        // Создаем получателя
        Light light = new Light();
        
        // Создаем команды
        Command turnOnCommand = new TurnOnLightCommand(light);
        Command turnOffCommand = new TurnOffLightCommand(light);
        
        // Создаем инициатора
        RemoteControl remote = new RemoteControl();
        
        // Выполняем команды
        remote.setCommand(turnOnCommand);
        remote.pressButton(); // Включаем свет
        
        remote.setCommand(turnOffCommand);
        remote.pressButton(); // Выключаем свет
    }
}
```

**Преимущества**:
- Отделяет объект, инициирующий операцию, от объекта, который знает, как ее выполнить
- Позволяет создавать последовательности команд (макрокоманды)
- Упрощает добавление новых команд без изменения существующего кода
- Поддерживает откат операций через механизм отмены
- Реализует отложенное выполнение

**Когда применять**:
- Когда нужно параметризовать объекты выполняемым действием
- Когда необходимо создавать и выполнять запросы в разное время
- Когда требуется поддержка отмены операций
- Когда требуется поддержка логирования изменений
- Для реализации механизма обратных вызовов

### 1.2. Шаблон "Стратегия" (Strategy)

**Назначение**: Шаблон "Стратегия" определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Позволяет изменять алгоритмы независимо от клиентов, которые их используют.

**Структура**:
- **Strategy** (стратегия) — интерфейс, общий для всех конкретных стратегий
- **ConcreteStrategy** (конкретная стратегия) — реализует алгоритм, следуя интерфейсу Strategy
- **Context** (контекст) — хранит ссылку на объект Strategy и может определять интерфейс, через который стратегия получает доступ к данным контекста

**Пример реализации**:
```java
// Интерфейс стратегии
interface PaymentStrategy {
    void pay(int amount);
}

// Конкретные стратегии
class CreditCardStrategy implements PaymentStrategy {
    private String name;
    private String cardNumber;
    private String cvv;
    private String dateOfExpiry;
    
    public CreditCardStrategy(String name, String cardNumber, String cvv, String dateOfExpiry) {
        this.name = name;
        this.cardNumber = cardNumber;
        this.cvv = cvv;
        this.dateOfExpiry = dateOfExpiry;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println(amount + " оплачено с помощью кредитной карты");
    }
}

class PayPalStrategy implements PaymentStrategy {
    private String email;
    private String password;
    
    public PayPalStrategy(String email, String password) {
        this.email = email;
        this.password = password;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println(amount + " оплачено с помощью PayPal");
    }
}

// Контекст
class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }
    
    public void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        
        // Оплата кредитной картой
        cart.setPaymentStrategy(new CreditCardStrategy("Иван Иванов", "1234567890123456", "123", "12/24"));
        cart.checkout(1000);
        
        // Оплата через PayPal
        cart.setPaymentStrategy(new PayPalStrategy("ivan@example.com", "password"));
        cart.checkout(500);
    }
}
```

**Преимущества**:
- Изолирует код алгоритмов от кода, который их использует
- Позволяет заменять алгоритмы во время выполнения
- Избавляет от использования множества условных операторов
- Упрощает расширение и добавление новых стратегий
- Разделяет бизнес-логику от деталей реализации алгоритмов

**Когда применять**:
- Когда есть множество родственных классов, отличающихся только поведением
- Когда необходимо использовать различные варианты алгоритма
- Когда алгоритм использует данные, о которых клиенты не должны знать
- Когда в классе есть условные операторы, определяющие, какое поведение должно быть выбрано

### 1.3. Шаблон "Шаблонный метод" (Template Method)

**Назначение**: Шаблон "Шаблонный метод" определяет скелет алгоритма в методе, оставляя определение некоторых шагов субклассам. Позволяет субклассам переопределять определенные шаги алгоритма без изменения его структуры.

**Структура**:
- **AbstractClass** (абстрактный класс) — определяет абстрактные примитивные операции, которые конкретные субклассы должны реализовать, а также реализует шаблонный метод, определяющий скелет алгоритма
- **ConcreteClass** (конкретный класс) — реализует примитивные операции, специфичные для конкретного субкласса

**Пример реализации**:
```java
// Абстрактный класс
abstract class BeverageTemplate {
    
    // Шаблонный метод
    public final void prepareBeverage() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }
    
    // Общие методы
    private void boilWater() {
        System.out.println("Кипячение воды");
    }
    
    private void pourInCup() {
        System.out.println("Наливаем в чашку");
    }
    
    // Методы, которые должны быть реализованы в субклассах
    protected abstract void brew();
    protected abstract void addCondiments();
    
    // Хук (hook) - метод с реализацией по умолчанию, который может быть переопределен
    protected boolean customerWantsCondiments() {
        return true;
    }
}

// Конкретный класс
class Tea extends BeverageTemplate {
    @Override
    protected void brew() {
        System.out.println("Завариваем чай");
    }
    
    @Override
    protected void addCondiments() {
        System.out.println("Добавляем лимон");
    }
}

// Конкретный класс
class Coffee extends BeverageTemplate {
    @Override
    protected void brew() {
        System.out.println("Завариваем кофе");
    }
    
    @Override
    protected void addCondiments() {
        System.out.println("Добавляем молоко и сахар");
    }
    
    @Override
    protected boolean customerWantsCondiments() {
        // Здесь может быть логика для определения, хочет ли клиент добавки
        return false;
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        BeverageTemplate tea = new Tea();
        tea.prepareBeverage();
        
        System.out.println("---------------");
        
        BeverageTemplate coffee = new Coffee();
        coffee.prepareBeverage();
    }
}
```

**Преимущества**:
- Повторное использование кода: общая логика алгоритма определена в родительском классе
- Расширяемость: позволяет подклассам расширять определенные шаги алгоритма без изменения его структуры
- Инверсия управления: родительский класс вызывает операции подкласса, а не наоборот
- Устранение дублирования кода в подклассах

**Когда применять**:
- Когда необходимо реализовать инвариантные части алгоритма один раз и оставить вариативное поведение для реализации в подклассах
- Когда общее поведение среди подклассов должно быть вынесено в один общий класс
- Когда нужно контролировать расширения подклассов

## 2. Архитектура программного обеспечения и влияние многопоточности

### 2.1. Что такое архитектура программного обеспечения

**Определение**: Архитектура программного обеспечения — это высокоуровневая структура программной системы, набор решений о:
- Организации системы
- Выборе структурных элементов и их интерфейсов
- Поведении этих элементов в составе системы
- Компоновке элементов в подсистемы
- Архитектурном стиле, который формирует все вышеперечисленное

Архитектура ПО определяет:
- Структуру системы (компоненты и их связи)
- Свойства системы (производительность, масштабируемость, безопасность)
- Компромиссы между различными аспектами системы

**Ключевые аспекты архитектуры ПО**:
1. **Структурные элементы**:
   - Компоненты (модули, сервисы, пакеты)
   - Соединители (API, протоколы, интерфейсы)
   - Данные (базы данных, файлы, потоки)

2. **Архитектурные стили и паттерны**:
   - Монолитная архитектура
   - Многоуровневая архитектура (N-tier)
   - Микросервисная архитектура
   - Событийно-ориентированная архитектура
   - Сервис-ориентированная архитектура (SOA)
   - Клиент-серверная архитектура
   - Пайплайн архитектура
   - Архитектура, основанная на плагинах

3. **Качественные атрибуты**:
   - Производительность
   - Масштабируемость
   - Модифицируемость
   - Тестируемость
   - Надежность
   - Безопасность
   - Удобство сопровождения
   - Доступность

4. **Принципы проектирования архитектуры**:
   - Разделение ответственности (Separation of Concerns)
   - Принцип единственной ответственности (Single Responsibility Principle)
   - Принцип открытости/закрытости (Open/Closed Principle)
   - Инверсия зависимостей (Dependency Inversion)
   - Минимизация связности между компонентами (Low Coupling)
   - Максимизация связности внутри компонентов (High Cohesion)

### 2.2. Влияние многопоточности на архитектуру ПО

Многопоточность существенно влияет на архитектуру программного обеспечения, добавляя дополнительный уровень сложности и требуя специальных подходов к проектированию. Рассмотрим основные аспекты влияния:

#### 2.2.1. Проблемы и вызовы многопоточности

1. **Состояние гонки (Race Conditions)**: Возникают, когда несколько потоков обращаются к общим данным одновременно. Это требует тщательного проектирования механизмов синхронизации.

2. **Взаимоблокировки (Deadlocks)**: Ситуации, когда два или более потоков ожидают ресурсы, занятые друг другом.

3. **Голодание потоков (Thread Starvation)**: Когда потоки не получают достаточно процессорного времени из-за неправильного планирования.

4. **Живые блокировки (Livelocks)**: Когда потоки постоянно реагируют на действия друг друга и не прогрессируют.

5. **Безопасность многопоточности (Thread Safety)**: Необходимость обеспечить корректную работу кода при одновременном выполнении несколькими потоками.

#### 2.2.2. Архитектурные подходы для многопоточных систем

1. **Потокобезопасные компоненты**:
   - Проектирование компонентов, которые могут безопасно использоваться в многопоточной среде
   - Инкапсуляция состояния и механизмов синхронизации

2. **Разделение на доменные модели**:
   - Изоляция частей системы, требующих синхронизации
   - Минимизация разделяемых данных между потоками

3. **Неизменяемые объекты (Immutable Objects)**:
   - Использование неизменяемых объектов для упрощения многопоточного доступа
   - Устранение необходимости в синхронизации для операций чтения

4. **Модель акторов (Actor Model)**:
   - Каждый актор имеет собственное состояние и может обмениваться сообщениями с другими акторами
   - Изоляция состояния в рамках актора упрощает параллельное выполнение

5. **Реактивная архитектура**:
   - Асинхронная, неблокирующая обработка событий
   - Позволяет эффективно использовать ресурсы при большом количестве параллельных операций

#### 2.2.3. Архитектурные паттерны для многопоточности

1. **Паттерн "Пул потоков" (Thread Pool)**:
   - Создание и поддержание фиксированного числа потоков для выполнения задач
   - Уменьшает накладные расходы на создание и уничтожение потоков

2. **Паттерн "Производитель-потребитель" (Producer-Consumer)**:
   - Разделение задач на производящие и потребляющие данные
   - Использование буферов или очередей для передачи данных между потоками

3. **Паттерн "Блокировка с двойной проверкой" (Double-Checked Locking)**:
   - Оптимизация производительности при реализации паттерна Singleton в многопоточной среде
   - Минимизация использования блокировок

4. **Паттерн "Читатели-писатели" (Readers-Writers)**:
   - Позволяет множеству читателей или одному писателю доступ к ресурсу
   - Оптимизирует доступ, когда операций чтения больше, чем операций записи

5. **Паттерн "Барьер" (Barrier)**:
   - Позволяет группе потоков ждать друг друга в определенной точке выполнения
   - Полезен для задач, требующих синхронизации по фазам

#### 2.2.4. Влияние на качественные атрибуты архитектуры

1. **Производительность**:
   - Многопоточность может значительно повысить производительность, но только при правильном проектировании
   - Необходимо учитывать накладные расходы на синхронизацию и переключение контекста

2. **Масштабируемость**:
   - Правильно спроектированные многопоточные системы лучше масштабируются при увеличении числа ядер
   - Закон Амдала ограничивает максимальное ускорение в зависимости от доли параллельного кода

3. **Тестируемость**:
   - Многопоточность значительно усложняет тестирование
   - Требуются специальные подходы для выявления проблем с синхронизацией

4. **Модифицируемость**:
   - Сложность многопоточного кода затрудняет его модификацию
   - Необходимо тщательно документировать предположения о синхронизации

5. **Надежность**:
   - Проблемы с синхронизацией могут привести к труднообнаруживаемым ошибкам
   - Требуется более строгий контроль качества

#### 2.2.5. Практические рекомендации для многопоточной архитектуры

1. **Минимизация общего состояния**:
   - Проектирование системы с минимальным количеством разделяемых данных
   - Использование локальных для потока данных где возможно

2. **Изоляция критических секций**:
   - Четкое выделение кода, требующего синхронизации
   - Минимизация размера критических секций

3. **Использование высокоуровневых абстракций**:
   - Применение готовых библиотек и фреймворков для параллельного программирования
   - Использование ExecutorService, CompletableFuture, Fork/Join в Java, Task в C# и т.д.

4. **Документирование многопоточных аспектов**:
   - Явное указание потокобезопасности компонентов
   - Документирование предположений о синхронизации

5. **Планирование для отказоустойчивости**:
   - Проектирование системы с учетом возможных проблем синхронизации
   - Механизмы восстановления после сбоев

#### Заключение

Многопоточность существенно влияет на архитектуру программного обеспечения, требуя специальных подходов к проектированию, реализации и тестированию. Хорошая многопоточная архитектура должна не только обеспечивать правильную работу в параллельной среде, но и сохранять такие качества как производительность, масштабируемость, тестируемость и модифицируемость.

При проектировании многопоточных систем критически важно понимать компромиссы между производительностью, сложностью и безопасностью, и выбирать подходящие архитектурные решения в зависимости от требований конкретной системы.